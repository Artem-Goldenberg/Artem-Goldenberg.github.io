{"sections":[],"primaryContentSections":[{"kind":"declarations","declarations":[{"tokens":[{"kind":"keyword","text":"#define"},{"text":" ","kind":"text"},{"text":"JTMap","kind":"identifier"},{"kind":"text","text":"("},{"kind":"internalParam","text":"mapper"},{"text":", ","kind":"text"},{"kind":"internalParam","text":"sep"},{"kind":"text","text":", ...)"}],"platforms":["macOS"],"languages":["occ"]}]},{"parameters":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A separator which will be used to separate the resulting sequence"}]}],"name":"sep"}],"kind":"parameters"},{"kind":"content","content":[{"text":"Overview","anchor":"Overview","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"Much more important than "},{"isActive":true,"type":"reference","identifier":"doc:\/\/JustText\/documentation\/JustText\/JTForEach"},{"text":" is the ","type":"text"},{"code":"Map","type":"codeVoice"},{"type":"text","text":". It is more generalised version of foreach, which supports"},{"text":" ","type":"text"},{"text":"arbitrary separators between token outputs, instead of just empty space as in the case of ","type":"text"},{"type":"codeVoice","code":"ForEach"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"Of course we could generate separators in our own ","type":"text"},{"type":"codeVoice","code":"mapper"},{"text":" macro which is invoked on every argument. But than,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"this corner case with the last argument, where we don’t need to insert a separator, we would have to always think about"},{"type":"text","text":" "},{"text":"this. Instead, ","type":"text"},{"type":"codeVoice","code":"Map"},{"type":"text","text":" will take care of it for you and only insert separator between elements and not after the last one."}],"type":"paragraph"},{"type":"heading","level":3,"text":"About separator","anchor":"About-separator"},{"inlineContent":[{"type":"text","text":"The thing about "},{"code":"sep","type":"codeVoice"},{"type":"text","text":" is that it is a real pain. Because it is very common to want to separate"},{"text":" ","type":"text"},{"type":"text","text":"results by a comma, but if we just pass "},{"type":"codeVoice","code":","},{"type":"text","text":" when invoking "},{"code":"Map","type":"codeVoice"},{"text":", obviously it would be wrong, because","type":"text"},{"type":"text","text":" "},{"type":"text","text":"preprocessor considers"},{"type":"codeVoice","code":","},{"text":" as argument separator and not as argument itself. So why don’t we just create a","type":"text"},{"type":"text","text":" "},{"type":"text","text":"special version of Argmap which would separate it’s outputs by a comma? Well, sometimes you need more complicated"},{"text":" ","type":"text"},{"text":"separators, with a comma inside of them somewhere. Maybe if user provides a macro which expands to comma, maybe","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"this would help? Well, if this macro needs to be applied to a set of parenthesys, then yes, it would work just fine. But to"},{"type":"text","text":" "},{"type":"text","text":"create a separate macro for each separator, even if it is a simple one seems like unnececcary work, besides adding more"},{"text":" ","type":"text"},{"type":"text","text":"macros to the code may decrease readability of code."}],"type":"paragraph"},{"inlineContent":[{"text":"The old library solution was to detect whether ","type":"text"},{"type":"codeVoice","code":"sep"},{"type":"text","text":" is enclosed in parenthesys, and if it is, then use what’s inside the parens"},{"type":"text","text":" "},{"text":"as a sep. If ","type":"text"},{"code":"sep","type":"codeVoice"},{"text":" is not in parentheses, then just use it as is.","type":"text"},{"text":" ","type":"text"},{"text":"This solution was very easy to use for the user, but the macro definition itself turned out to be very unreadable because of it.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"So in this library, there are three different maps (at least for now): this one which accepts a simple plan seperator without","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"commas, another one which, like in the old library, extracts separator from the parens around it, and last one which would"},{"type":"text","text":" "},{"type":"text","text":"accept a separator producer and invoke it when the separator is needed, it may even take as arguments the two elements"},{"text":" ","type":"text"},{"text":"which needs to be separated by this in the future.","type":"text"}]}]}],"seeAlsoSections":[{"identifiers":["doc:\/\/JustText\/documentation\/JustText\/JTForEach","doc:\/\/JustText\/documentation\/JustText\/JTMapPlain","doc:\/\/JustText\/documentation\/JustText\/JTMapComma","doc:\/\/JustText\/documentation\/JustText\/JTMapParenSep","doc:\/\/JustText\/documentation\/JustText\/JTMapMakeSep"],"generated":true,"anchor":"Public-Mappers","title":"Public Mappers"}],"identifier":{"url":"doc:\/\/JustText\/documentation\/JustText\/JTMap","interfaceLanguage":"occ"},"kind":"symbol","metadata":{"navigatorTitle":[{"kind":"identifier","text":"JTMap"}],"externalID":"c:JustText.h@626@macro@JTMap","modules":[{"name":"JustText"}],"role":"symbol","fragments":[{"kind":"identifier","text":"JTMap"}],"title":"JTMap","roleHeading":"Macro","symbolKind":"macro"},"hierarchy":{"paths":[["doc:\/\/JustText\/documentation\/JustText"]]},"abstract":[{"text":"Applies first argument to all the rest, and custom glue the results","type":"text"}],"variants":[{"traits":[{"interfaceLanguage":"occ"}],"paths":["\/documentation\/justtext\/jtmap"]}],"schemaVersion":{"major":0,"patch":0,"minor":3},"references":{"doc://JustText/documentation/JustText/JTMapComma":{"url":"\/documentation\/justtext\/jtmapcomma","kind":"symbol","identifier":"doc:\/\/JustText\/documentation\/JustText\/JTMapComma","type":"topic","fragments":[{"text":"JTMapComma","kind":"identifier"}],"role":"symbol","abstract":[{"type":"text","text":"Maps arguments, putting comma in-between"}],"title":"JTMapComma"},"doc://JustText/documentation/JustText":{"identifier":"doc:\/\/JustText\/documentation\/JustText","kind":"symbol","url":"\/documentation\/justtext","title":"JustText","abstract":[{"inlineContent":[{"type":"text","text":"After all, it’s just a bunch of text"}],"type":"emphasis"}],"role":"collection","type":"topic"},"doc://JustText/documentation/JustText/JTMap":{"url":"\/documentation\/justtext\/jtmap","type":"topic","title":"JTMap","kind":"symbol","identifier":"doc:\/\/JustText\/documentation\/JustText\/JTMap","role":"symbol","abstract":[{"type":"text","text":"Applies first argument to all the rest, and custom glue the results"}],"fragments":[{"kind":"identifier","text":"JTMap"}]},"doc://JustText/documentation/JustText/JTMapPlain":{"url":"\/documentation\/justtext\/jtmapplain","fragments":[{"text":"JTMapPlain","kind":"identifier"}],"identifier":"doc:\/\/JustText\/documentation\/JustText\/JTMapPlain","title":"JTMapPlain","abstract":[{"text":"Maps arguments using a simple separator in-between","type":"text"}],"kind":"symbol","role":"symbol","type":"topic"},"doc://JustText/documentation/JustText/JTMapMakeSep":{"url":"\/documentation\/justtext\/jtmapmakesep","kind":"symbol","identifier":"doc:\/\/JustText\/documentation\/JustText\/JTMapMakeSep","type":"topic","fragments":[{"text":"JTMapMakeSep","kind":"identifier"}],"role":"symbol","abstract":[{"type":"text","text":"Maps arguments, putting a specifically produced separator in-between"}],"title":"JTMapMakeSep"},"doc://JustText/documentation/JustText/JTMapParenSep":{"role":"symbol","identifier":"doc:\/\/JustText\/documentation\/JustText\/JTMapParenSep","title":"JTMapParenSep","kind":"symbol","url":"\/documentation\/justtext\/jtmapparensep","fragments":[{"text":"JTMapParenSep","kind":"identifier"}],"abstract":[{"type":"text","text":"Maps arguments, putting unpacked separator in-between"}],"type":"topic"},"doc://JustText/documentation/JustText/JTForEach":{"role":"symbol","identifier":"doc:\/\/JustText\/documentation\/JustText\/JTForEach","title":"JTForEach","kind":"symbol","url":"\/documentation\/justtext\/jtforeach","fragments":[{"text":"JTForEach","kind":"identifier"}],"abstract":[{"type":"text","text":"Applies it’s first argument to all the rest"}],"type":"topic"}}}